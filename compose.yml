name: short_and_exact

services:
        api:
              image: api_img:latest

              restart: always   # Ensures the container restarts automatically if it crashes
              
              deploy:
                resources:
                  limits:
                    memory: 3g
                replicas: 3

              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:7860/healthy"]
                interval: 60s
                timeout: 3s
                retries: 3
                start_period: 10s

              depends_on:
                db:
                  condition: service_healthy
                redis:
                  condition: service_healthy

              # ports:
              #   - "8000:7860"   





# the port 7860 has specfied to be already expose ...we are specify it to be exposed to the 8000 port of the local computer.
# Any request recieved by the former will be forwarded to the latter
# in the api docker image, we have specified that the api runs on port 7860 internally

        redis:
              image: redis:6.2-alpine   # smaller version of redis

              restart: always   # Ensures the container restarts automatically if it crashes

              deploy:
                resources:
                  limits:
                    memory: 1g

              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 60s
                timeout: 3s
                retries: 3
                start_period: 10s

              # ports:
              #   - "6379:6379"

              command: redis-server --save 10 1 --loglevel warning  # overrirding the command in the redis docker image
              volumes:
                - ./redis-data:/data
# we dont need to expose any port of the redis container to the local computer port 
# redis interally runs on port 6379

        db:
          image: postgres  # latest stable image of postgres SQL

          restart: always # Ensures the container restarts automatically if it crashes

          environment:
            POSTGRES_DB: "short_and_exact" # Sets the default database name
            POSTGRES_USER: "Aditya Goyal" # Sets the default user for the database
            POSTGRES_PASSWORD: "cold feather" # Sets the password for the default user

          deploy: 
            resources:
              limits:
                memory: 3g

          healthcheck:
            test: ["CMD-SHELL", "pg_isready" ,"-h" ,"postgres" ,"-p" ,"5432" ,"-U" ,"Aditya Goyal" ,"-d" ,"short_and_exact"]
            interval: 60s
            timeout: 3s
            retries: 3
            start_period: 10s

            
          # ports:
          #   - 5432:5432

          volumes:
            - ./postgre_db:/var/lib/postgresql/data
            - ./init.sql:/docker-entrypoint-initdb.d/create_tables.sql

        frontend:

          image: frontend_img:latest

          restart: always

          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:3000"]
            interval: 60s
            timeout: 3s
            retries: 3
            start_period: 10s
            
          ports:
            - 3000:3000

          depends_on:
            api:
              condition: service_healthy

        
        lb:

         image: lb_img:latest

         restart: always  

         depends_on:
            api:
              condition: service_started

         ports:
              - 4000:4000


        pgbouncer:
          image: edoburu/pgbouncer
          # restart: always

          depends_on:
            db:
              condition: service_healthy

          environment:
            DB_USER: "Aditya Goyal"
            DB_PASSWORD: "cold feather"

          volumes:
            - ./pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini

          ports:
            - "6432:6432"










# integrating contianer monitoring and handling dependcies 
# using healthchecks and depends on

# The HEALTHCHECK instruction in a Dockerfile or the healthcheck configuration in Docker Compose defines a 
# command or script that Docker will execute within the running container. This command is designed to verify 
# the health and responsiveness of the application or service running inside that specific container.

# Docker does not automatically stop dependent containers if a healthcheck fails later after startup


# the dependent service won’t fail outright — as long as at least one replica of its dependent is still healthy and reachable